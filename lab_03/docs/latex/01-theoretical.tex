\chapter{Аналитическая часть}

\section{Пузырьковая сортировка}

\subsection{Описание алгоритма}

Алгоритм состоит из повторяющихся проходов по сортируемому массиву.
За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов.
Проходы по массиву повторяются $N-1$ раз, но есть модифицированная версия, где если окажется, что обмены больше не нужны, значит проходы прекращаются.
При каждом проходе алгоритма по внутреннему циклу очередной наибольший элемент массива ставится на свое место в конце массива рядом с предыдущим ``наибольшим элементом'', а наименьший элемент массива перемещается на одну позицию к началу массива (``всплывает'' до нужной позиции, как пузырёк в воде -- отсюда и название алгоритма).

\subsection{Псевдокод}

\begin{algorithmic}
\Procedure{BubbleSort}{$A$}
\State $n \gets$ \texttt{len}($A$)
\For{$i \gets 1$ \textbf{to} $n$}
\For{$j \gets 1$ \textbf{to} $n - i$}
\If{$A[j] > A[j + 1]$}
\State $SWAP(A[j], A[j + 1])$
\EndIf
\EndFor
\EndFor
\EndProcedure
\end{algorithmic}

\subsection{Анализ алгоритма}

\begin{itemize}
    \item Время выполнения алгоритма: $O(n^2)$
    \item Память: $O(1)$
\end{itemize}

\section{Сортировка подсчетом}

\subsection{Описание алгоритма}

Сортировка подсчетом — простейший способ упорядочить массив за линейное время.
Применять его можно только для целых чисел, небольшого диапазона,
т.к. он требует O(M) дополнительной памяти,
где M — ширина диапазона сортируемых чисел.
Алгоритм особо эффективен когда мы сортируем большое количество чисел,
значения которых имеют небольшой разброс — например: массив из 1000000 целых чисел,
которые принимают значения от 0 до 1000.

\subsection{Псевдокод}

\begin{algorithmic}
\Procedure{Counting Sort}{$A$}
\State $n \gets$ \texttt{len}($A$)
\State $C \gets$ \texttt{new} \texttt{array}($n$)
\For{$i \gets 1$ \textbf{to} $n$}
\State $C[i] \gets 0$
\EndFor
\For{$i \gets 1$ \textbf{to} $n$}
\State $C[A[i]] \gets C[A[i]] + 1$
\EndFor
%\For{$i \gets 2$ \textbf{to} $n$}
%\State $C[i] \gets C[i] + C[i - 1]$
%\EndFor
\State $i \gets$ 0
\State $j \gets$ 0
\While{$i \neq len(A) \&\& j \neq n$}
\If{$C[j] \neq 0$}
\State $A[i] \gets j$
\State $C[j] \gets C[j] - 1$
\State $i \gets i + 1$
\Else
\State $j \gets j + 1$
\EndIf
\EndWhile
\EndProcedure
\end{algorithmic}

\subsection{Анализ алгоритма}

\begin{itemize}
    \item Время выполнения алгоритма: $O(n + k)$
    \item Память: $O(n + k)$
    \begin{itemize}
        \item[$-$] $n$ - размер массива
        \item[$-$] $k$ - максимальное значение элемента массива
    \end{itemize}
    \item Сортировка подсчетом работает только с целыми числами
    \item Сортировка подсчетом не является устойчивой
    \item Сортировка подсчетом не подходит для сортировки больших массивов
\end{itemize}

\section{Быстрая сортировка}

\subsection{Описание алгоритма}

Общая идея алгоритма состоит в следующем:

\begin{itemize}
    \item выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность
    \item сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
    \item для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
\end{itemize}

На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.

\subsection{Псевдокод}

\begin{algorithmic}
\Procedure{QuickSort}{$A$}
\State $n \gets$ \texttt{len}($A$)
\State $S \gets \{\}$ \Comment{Стек}
\State $S \gets S \cup \{0, n - 1\}$
\While{$S \neq \{\}$}
\State $r \gets S[n_S - 1]$
\State $l \gets S[n_S - 2]$
\State $S \gets S \setminus \{r, l\}$
\State $p \gets$ \texttt{partition}($A, l, r$)
%\If{$p - 1 > l$}
\State $S \gets S \cup \{l, p - 1\}$
%\EndIf
%\If{$p + 1 < r$}
\State $S \gets S \cup \{p + 1, r\}$
%\EndIf
\EndWhile
\EndProcedure
\end{algorithmic}

\subsection{Анализ алгоритма}

\begin{itemize}
    \item Время выполнения алгоритма: $O(n \log n)$
    \item Память: $O(\log n)$
\end{itemize}

\section*{Вывод}

В данном разделе были описаны основные алгоритмы сортировки.
Были рассмотрены следующие алгоритмы:
\begin{itemize}
    \item Сортировка пузырьком
    \item Сортировка подсчетом
    \item Быстрая сортировка
\end{itemize}

Были рассмотрены их особенности, сложность, а также приведен псевдокод.