\chapter{Исследовательская часть}
Ниже приведены технические характеристики устройства, на котором было проведено тестирование ПО:

\begin{itemize}
    \item Операционная система: Windows 11 используя Windows Subsystem for Linux 2 (WSL2) \cite{wsl2} Имитирующей Arch Linux \cite{arch} 64-bit.
    \item Оперативная память: 16 Гб.
    \item Процессор: 11th Gen Intel(R) Core(TM) i5-11320H @ 3.20 ГГц \cite{i5}.
\end{itemize}

\section{Время выполнения алгоритмов}
Алгоритмы тестировались при помощи \("\)бенчмарков\("\) предоставляемых встренными средствами языка Go \cite{go}.
Пример такого "бенчмарка приведен в листинге \ref{lst:benchmark}.
Количество повторов регулируется тестирующей системой самоятоятельно, хотя при желание оные можно задать.
Точное количество повторов определяется в зависимости от того, был ли получен стабильный результат согласно системе.

\lstinputlisting[style=go, caption={Пример бенчмарка}, label={lst:benchmark} , firstline=102, lastline=117]{../../src/levenshtein/levenshtein_test.go}

График времени выполнения алгоритмов на случайных данных (в наносекундах)\newline
\includesvg[%
    width=18cm,height=15cm,inkscapelatex=false,
    %inkscapeformat=pdf,
%  inkscapelatex=false,
%  distort=true,
%    angle=-12.5,
%  extractdistort=false,
%  extractangle=inherit,
]{plot-time}%
\section{Использование памяти}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Поэтому, максимальный расход памяти равен:

\begin{equation}
(\mathcal{S}(STR_1) + \mathcal{S}(STR_2)) \cdot (2 \cdot \mathcal{S}\mathrm{(string)} + 3 \cdot \mathcal{S}\mathrm{(integer)}),
\end{equation}

\noindent где $\mathcal{S}$ — оператор вычисления размера, $STR_1$, $STR_2$ — строки, $\mathrm{string}$ — строковый тип,

\noindent $\mathrm{integer}$ — целочисленный тип.

Использование памяти при итеративной реализации теоретически равно:
\begin{equation}
(\mathcal{S}(STR_1) + 1) \cdot (\mathcal{S}(STR_2) + 1) \cdot \mathcal{S}\mathrm{(integer)} + 5\cdot \mathcal{S}\mathrm{(integer)} + 2 \cdot \mathcal{S}\mathrm{(string)}.
\end{equation}

\section*{Вывод}

Рекурсивная реализация алгоритма нахождения расстояния Левенштейна работает дольше остальных реализаций, а
время работы этой реализации увеличивается в геометрической прогрессии.
Это происходит из-за того, что при рекурсивной реализации алгоритма на каждом шаге необходимо заново вычислять расстояние Левенштейна для подстрок,
что приводит к большому количеству вызовов функции.

Также стоит отметить, что рекурсивная реализация алгоритма нахождения расстояния Левенштейна не подходит для больших строк,
так как при больших значениях глубины стека вызовов возникает переполнение стека.

Согласно графикам, время выполнения рекурсивного алгоритма с кешем также работает медленнее итеративного.
Связано это с тем, что в рекусривной версии алгоритма присутствуют дополнительные затраты памяти и процессорного времени на вызовы функций.
