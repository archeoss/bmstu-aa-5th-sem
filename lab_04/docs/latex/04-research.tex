\chapter{Исследовательская часть}
Ниже приведены технические характеристики устройства, на котором было проведено тестирование ПО.

\begin{itemize}
    \item[$-$] Операционная система: Arch Linux~\cite{arch} 64-bit.
    \item[$-$] Оперативная память: 16 Гбайт, DDR4.
    \item[$-$] Процессор: 11th Gen Intel\textsuperscript{\tiny\textregistered} Core\textsuperscript{\tiny\texttrademark} i5-11320H @ 3.20 ГГц~\cite{i5}. 4 - физических ядра, 8 - логических.
\end{itemize}

\section{Пример выполнения}
На рис.~\ref{img:serial} приведен пример выполнения реализации последовательного алгоритма, на рис.~\ref{img:parallel_1} -- \ref{img:parallel_4} --- параллельного.
\includeimage
{serial} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.75\textwidth} % Ширина рисунка
{Пример выполнения DBSCAN, последовательный алгоритм} % Подпись рисунка

\includeimage
{parallel_1} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.75\textwidth} % Ширина рисунка
{Пример выполнения DBSCAN, параллельный алгоритм, 1 поток} % Подпись рисунка

\includeimage
{parallel_2} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.75\textwidth} % Ширина рисунка
{Пример выполнения DBSCAN, параллельный алгоритм, 2 потока} % Подпись рисунка


\includeimage
{parallel_4} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.75\textwidth} % Ширина рисунка
{Пример выполнения DBSCAN, параллельный алгоритм, 4 потока} % Подпись рисунка

\clearpage

\section{Время выполнения алгоритмов}
Алгоритмы тестировались при помощи инструментов замера времени предоставляемых библиотекой Criterion.rs\cite{Criterion}.
Пример функции по замеру времени приведен в листинге \ref{lst:benchmark}.
Количество повторов регулируется тестирующей системой самостоятельно, однако ввиду трудоемкости вычислений, количество повторов было ограничено до 25.
\lstinputlisting[language=Rust, style=rust, caption={Пример функции замера времени}, label={lst:benchmark} , firstline=12, lastline=42]{../../benches/bench.rs}

\newpage
График, показывающий время работы последовательного и параллельного алгоритмов в зависимости от количества потоков\newline
%\includesvg[%
%    width=18cm,height=15cm,inkscapelatex=false,
%%inkscapeformat=pdf,
%%  inkscapelatex=false,
%%  distort=true,
%%    angle=-12.5,
%%  extractdistort=false,
%%  extractangle=inherit,
%]{even-bench.svg}%
\includeimage
{plot} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Время работы DBSCAN} % Подпись рисунка
\newpage

Как видно из полученных данных (на рис.~\ref{img:plot}), параллельная реализация работает быстрее, чем последовательная, при количестве рабочих потоков от 1 до 16. 
Более быстрая работа параллельного алгоритма при одном потоке по сравнению с последовательным алгоритмом может быть объяснена различнымии оптимизациями, которые были реализованы в ходе написания параллельного алгоритма.
В частности, при параллельной реализации алгоритма мы не обязаны посещать все точки и просчитывать расстояние до каждой точки пространства --- в случае, если ячейка содержит MinPt количестов точек, то вся ячейка отмечается как часть кластера и нет необходимости в дополнительном просчете расстояния (гарантировано, что все точки внутри ячейки находятся на расстоянии меньше eps).
Затраты, связанные с созданием поток(-а/-ов) при этом несущественны.
Начиная с 8 рабочих потоков, процессорное время работы параллельной реализации растёт, и, при 32 рабочих потоках, время работы параллельного алгоритма превышает время работы последовательного.
Такой рост связан с тем, что задействованный процессор не может эффективно обслуживать более 8 потоков, имея 8 логических ядер, что объясняет полученные результаты.

\section*{Вывод}
В результате эксперимента было установлено, что параллельная реализация алгоритма DBSCAN работает быстрее, чем последовательная, при количестве рабочих потоков от 1 до 16 рабочих потоках. 
Это связано с тем, что использование более 8 рабочих потоков приводит к излишним временным затратам на диспетчеризацию потоков, поскольку на 1 логическое ядро приходится более 1 потока вычисления.


